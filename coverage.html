
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>parser-kit: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/soulteary/parser-kit/loader.go (94.7%)</option>
				
				<option value="file1">github.com/soulteary/parser-kit/types.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package parserkit

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "sort"

        "github.com/redis/go-redis/v9"
        "github.com/soulteary/http-kit"
)

// loader is the default implementation of DataLoader
type loader[T any] struct {
        options       *LoadOptions
        client        *httpkit.Client
        normalizeFunc NormalizeFunc[T]
        keyFunc       func(T) (string, bool) // Extracted from LoadOptions.KeyFunc
}

// NewLoader creates a new generic data loader
func NewLoader[T any](opts *LoadOptions) (DataLoader[T], error) <span class="cov9" title="37">{
        return NewLoaderWithNormalize[T](opts, nil)
}</span>

// NewLoaderWithNormalize creates a new generic data loader with normalization function
func NewLoaderWithNormalize[T any](opts *LoadOptions, normalizeFunc NormalizeFunc[T]) (DataLoader[T], error) <span class="cov10" title="39">{
        if opts == nil </span><span class="cov6" title="11">{
                opts = DefaultLoadOptions()
        }</span> else<span class="cov9" title="28"> {
                // MaxFileSize 0 would cause io.LimitReader to read 0 bytes; use default when unset
                if opts.MaxFileSize == 0 </span><span class="cov2" title="2">{
                        opts.MaxFileSize = DefaultLoadOptions().MaxFileSize
                }</span>
                <span class="cov9" title="28">if opts.LoadStrategy == "" </span><span class="cov2" title="2">{
                        opts.LoadStrategy = LoadStrategyFallback
                }</span>
        }

        // Validate LoadStrategy and KeyFunc
        <span class="cov10" title="39">if opts.LoadStrategy == LoadStrategyMerge </span><span class="cov5" title="7">{
                if opts.KeyFunc == nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("KeyFunc is required when LoadStrategy is LoadStrategyMerge")
                }</span>
        }

        // Create HTTP client for remote requests
        // BaseURL is required by http-kit but we use full URLs in requests
        <span class="cov9" title="38">httpOpts := &amp;httpkit.Options{
                BaseURL:            "http://localhost", // Placeholder, not used since we use full URLs
                Timeout:            opts.HTTPTimeout,
                InsecureSkipVerify: opts.InsecureSkipVerify,
        }
        client, err := httpkit.NewClient(httpOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP client: %w", err)
        }</span>

        // Extract keyFunc from interface{} via type assertion (KeyFunc must be func(T) (string, bool))
        <span class="cov9" title="38">var keyFunc func(T) (string, bool)
        if opts.KeyFunc != nil </span><span class="cov5" title="6">{
                if kf, ok := opts.KeyFunc.(func(T) (string, bool)); ok </span><span class="cov4" title="5">{
                        keyFunc = kf
                }</span> else<span class="cov1" title="1"> {
                        return nil, fmt.Errorf("KeyFunc must be of type func(T) (string, bool) for LoadStrategyMerge")
                }</span>
        }

        <span class="cov9" title="37">return &amp;loader[T]{
                options:       opts,
                client:        client,
                normalizeFunc: normalizeFunc,
                keyFunc:       keyFunc,
        }, nil</span>
}

// FromFile loads data from a local file
func (l *loader[T]) FromFile(ctx context.Context, path string) ([]T, error) <span class="cov8" title="21">{
        // Check if file exists
        if _, err := os.Stat(path); err != nil </span><span class="cov4" title="4">{
                if os.IsNotExist(err) </span><span class="cov4" title="4">{
                        if l.options.AllowEmptyFile </span><span class="cov1" title="1">{
                                return []T{}, nil // Return empty slice instead of error
                        }</span>
                        <span class="cov3" title="3">return nil, fmt.Errorf("file not found: %s", path)</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to stat file: %w", err)</span>
        }

        // Open file
        <span class="cov7" title="17">file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open file: %w", err)
        }</span>
        <span class="cov7" title="17">defer file.Close()

        // Read file with size limit
        raw, err := io.ReadAll(io.LimitReader(file, l.options.MaxFileSize))
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Parse JSON
        <span class="cov7" title="16">var data []T
        if err := json.Unmarshal(raw, &amp;data); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse JSON: %w", err)
        }</span>

        // Normalize if function provided
        <span class="cov7" title="15">if l.normalizeFunc != nil </span><span class="cov1" title="1">{
                data = l.normalizeFunc(data)
        }</span>

        <span class="cov7" title="15">return data, nil</span>
}

// FromRemote loads data from a remote URL
func (l *loader[T]) FromRemote(ctx context.Context, url, auth string) ([]T, error) <span class="cov6" title="9">{
        // Create request
        req, err := http.NewRequestWithContext(ctx, "GET", url, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov6" title="9">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Cache-Control", "max-age=0")
        if auth != "" </span><span class="cov1" title="1">{
                req.Header.Set("Authorization", auth)
        }</span>

        // Inject trace context if available
        <span class="cov6" title="9">l.client.InjectTraceContext(ctx, req)

        // Retry options
        retryOpts := &amp;httpkit.RetryOptions{
                MaxRetries:        l.options.MaxRetries,
                RetryDelay:        l.options.RetryDelay,
                BackoffMultiplier: 2.0,
                RetryableStatusCodes: []int{
                        http.StatusRequestTimeout,
                        http.StatusTooManyRequests,
                        http.StatusInternalServerError,
                        http.StatusBadGateway,
                        http.StatusServiceUnavailable,
                        http.StatusGatewayTimeout,
                },
        }

        // Execute request with retry
        resp, err := l.client.DoRequestWithRetry(ctx, req, retryOpts)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to fetch remote data: %w", err)
        }</span>
        <span class="cov6" title="8">defer resp.Body.Close()

        // Check status code
        if resp.StatusCode != http.StatusOK </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        // Read response body with size limit
        <span class="cov5" title="6">body, err := io.ReadAll(io.LimitReader(resp.Body, l.options.MaxFileSize))
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        // Parse JSON
        <span class="cov4" title="5">var data []T
        if err := json.Unmarshal(body, &amp;data); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse JSON: %w", err)
        }</span>

        // Normalize if function provided
        <span class="cov4" title="4">if l.normalizeFunc != nil </span><span class="cov0" title="0">{
                data = l.normalizeFunc(data)
        }</span>

        <span class="cov4" title="4">return data, nil</span>
}

// FromRedis loads data from Redis
func (l *loader[T]) FromRedis(ctx context.Context, client interface{}, key string) ([]T, error) <span class="cov5" title="6">{
        // Type assert to redis.Client
        redisClient, ok := client.(*redis.Client)
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid Redis client type")
        }</span>

        // Get data from Redis
        <span class="cov4" title="5">val, err := redisClient.Get(ctx, key).Result()
        if err != nil </span><span class="cov3" title="3">{
                if err == redis.Nil </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("key not found in Redis: %s", key)
                }</span>
                <span class="cov1" title="1">return nil, fmt.Errorf("failed to get from Redis: %w", err)</span>
        }

        // Parse JSON
        <span class="cov2" title="2">var data []T
        if err := json.Unmarshal([]byte(val), &amp;data); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to parse JSON: %w", err)
        }</span>

        // Normalize if function provided
        <span class="cov1" title="1">if l.normalizeFunc != nil </span><span class="cov0" title="0">{
                data = l.normalizeFunc(data)
        }</span>

        <span class="cov1" title="1">return data, nil</span>
}

// Load loads data from multiple sources with priority-based fallback or merge
func (l *loader[T]) Load(ctx context.Context, sources ...Source) ([]T, error) <span class="cov8" title="18">{
        if len(sources) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no sources provided")
        }</span>

        // Sort sources by priority (lower number = higher priority)
        <span class="cov7" title="17">sortedSources := make([]Source, len(sources))
        copy(sortedSources, sources)
        sort.Slice(sortedSources, func(i, j int) bool </span><span class="cov4" title="4">{
                return sortedSources[i].Priority &lt; sortedSources[j].Priority
        }</span>)

        // Determine strategy
        <span class="cov7" title="17">strategy := l.options.LoadStrategy
        if strategy == "" </span><span class="cov0" title="0">{
                strategy = LoadStrategyFallback
        }</span>

        <span class="cov7" title="17">if strategy == LoadStrategyMerge </span><span class="cov4" title="5">{
                return l.loadWithMerge(ctx, sortedSources)
        }</span>

        // Fallback strategy: return first successful source
        <span class="cov7" title="12">return l.loadWithFallback(ctx, sortedSources)</span>
}

// loadWithFallback implements fallback strategy: returns data from first successful source
func (l *loader[T]) loadWithFallback(ctx context.Context, sources []Source) ([]T, error) <span class="cov7" title="12">{
        var lastErr error
        for _, source := range sources </span><span class="cov7" title="15">{
                data, err := l.loadFromSource(ctx, source)
                if err != nil </span><span class="cov5" title="7">{
                        lastErr = err
                        continue</span>
                }

                // If successful, check if we should return or continue
                <span class="cov6" title="8">if len(data) &gt; 0 </span><span class="cov5" title="6">{
                        return data, nil
                }</span>
                <span class="cov2" title="2">if !l.options.AllowEmptyData </span><span class="cov1" title="1">{
                        // Empty data but no error - continue to next source
                        lastErr = fmt.Errorf("source returned empty data")
                        continue</span>
                }
                // AllowEmptyData is true, return empty data
                <span class="cov1" title="1">return data, nil</span>
        }

        // All sources failed
        <span class="cov4" title="5">return nil, fmt.Errorf("all sources failed, last error: %w", lastErr)</span>
}

// loadWithMerge implements merge strategy: merges data from all successful sources with deduplication
func (l *loader[T]) loadWithMerge(ctx context.Context, sources []Source) ([]T, error) <span class="cov4" title="5">{
        if l.keyFunc == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("KeyFunc is required for merge strategy")
        }</span>

        // Use map for deduplication and slice for order
        <span class="cov4" title="5">dict := make(map[string]T)
        order := make([]string, 0)
        var lastErr error
        hasData := false

        for _, source := range sources </span><span class="cov5" title="6">{
                data, err := l.loadFromSource(ctx, source)
                if err != nil </span><span class="cov1" title="1">{
                        lastErr = err
                        continue</span>
                }

                // Merge data into dict
                <span class="cov4" title="5">for _, item := range data </span><span class="cov5" title="6">{
                        key, include := l.keyFunc(item)
                        if !include </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov4" title="5">if _, exists := dict[key]; !exists </span><span class="cov4" title="4">{
                                order = append(order, key)
                        }</span>
                        <span class="cov4" title="5">dict[key] = item
                        hasData = true</span>
                }
        }

        <span class="cov4" title="5">if !hasData </span><span class="cov3" title="3">{
                if lastErr != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("all sources failed, last error: %w", lastErr)
                }</span>
                <span class="cov2" title="2">if !l.options.AllowEmptyData </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("all sources returned empty data")
                }</span>
                <span class="cov1" title="1">return []T{}, nil</span>
        }

        // Convert map back to slice maintaining order
        <span class="cov2" title="2">result := make([]T, 0, len(order))
        for _, key := range order </span><span class="cov4" title="4">{
                if item, exists := dict[key]; exists </span><span class="cov4" title="4">{
                        result = append(result, item)
                }</span>
        }

        <span class="cov2" title="2">return result, nil</span>
}

// loadFromSource loads data from a single source
func (l *loader[T]) loadFromSource(ctx context.Context, source Source) ([]T, error) <span class="cov8" title="21">{
        switch source.Type </span>{
        case SourceTypeFile:<span class="cov7" title="14">
                if source.Config.FilePath == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("file path not specified")
                }</span>
                <span class="cov7" title="13">return l.FromFile(ctx, source.Config.FilePath)</span>

        case SourceTypeRedis:<span class="cov2" title="2">
                if source.Config.RedisKey == "" || source.Config.RedisClient == nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("Redis key or client not specified")
                }</span>
                <span class="cov1" title="1">return l.FromRedis(ctx, source.Config.RedisClient, source.Config.RedisKey)</span>

        case SourceTypeRemote:<span class="cov4" title="4">
                if source.Config.RemoteURL == "" </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("remote URL not specified")
                }</span>
                <span class="cov3" title="3">timeout := source.Config.Timeout
                if timeout == 0 </span><span class="cov2" title="2">{
                        timeout = l.options.HTTPTimeout
                }</span>
                // Create a context with timeout if specified
                <span class="cov3" title="3">loadCtx := ctx
                if timeout &gt; 0 </span><span class="cov3" title="3">{
                        var cancel context.CancelFunc
                        loadCtx, cancel = context.WithTimeout(ctx, timeout)
                        defer cancel()
                }</span>
                // Note: InsecureSkipVerify is set at client creation time in NewLoader.
                // If source.Config.InsecureSkipVerify is set, it will be ignored in favor of the global option.
                // For per-source TLS configuration, create separate loader instances.
                <span class="cov3" title="3">return l.FromRemote(loadCtx, source.Config.RemoteURL, source.Config.AuthorizationHeader)</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unknown source type: %s", source.Type)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package parserkit

import (
        "context"
        "time"
)

// SourceType represents the type of data source
type SourceType string

const (
        // SourceTypeFile represents a local file source
        SourceTypeFile SourceType = "file"
        // SourceTypeRedis represents a Redis source
        SourceTypeRedis SourceType = "redis"
        // SourceTypeRemote represents a remote HTTP/HTTPS source
        SourceTypeRemote SourceType = "remote"
)

// SourceConfig holds configuration for a data source
type SourceConfig struct {
        // For file source
        FilePath string

        // For Redis source
        RedisKey    string
        RedisClient interface{} // *redis.Client from redis-kit

        // For remote source
        RemoteURL           string
        AuthorizationHeader string
        Timeout             time.Duration
        InsecureSkipVerify  bool
}

// Source represents a data source with priority
type Source struct {
        Type     SourceType
        Priority int // Lower number = higher priority (0 is highest)
        Config   SourceConfig
}

// DataLoader is a generic interface for loading data from various sources
type DataLoader[T any] interface {
        // FromFile loads data from a local file
        FromFile(ctx context.Context, path string) ([]T, error)

        // FromRemote loads data from a remote URL
        FromRemote(ctx context.Context, url, auth string) ([]T, error)

        // FromRedis loads data from Redis
        FromRedis(ctx context.Context, client interface{}, key string) ([]T, error)

        // Load loads data from multiple sources
        // Sources are processed in priority order (lower number = higher priority)
        // Behavior depends on LoadStrategy:
        // - LoadStrategyFallback: returns data from the first successful source
        // - LoadStrategyMerge: merges data from all successful sources with deduplication
        Load(ctx context.Context, sources ...Source) ([]T, error)
}

// NormalizeFunc is a function type for normalizing data after parsing
// It accepts a slice of any type and returns a normalized slice
type NormalizeFunc[T any] func([]T) []T

// KeyFunc extracts a unique key from an item for deduplication
// Returns the key and true if the item should be included, false otherwise
type KeyFunc[T any] func(T) (string, bool)

// LoadStrategy determines how data from multiple sources should be combined
type LoadStrategy string

const (
        // LoadStrategyFallback returns data from the first successful source (default)
        LoadStrategyFallback LoadStrategy = "fallback"
        // LoadStrategyMerge merges data from all successful sources with deduplication
        LoadStrategyMerge LoadStrategy = "merge"
)

// LoadOptions configures the behavior of Load operations
type LoadOptions struct {
        // MaxFileSize limits the maximum file size to read (default: 10MB)
        MaxFileSize int64

        // MaxRetries for remote requests (default: 3)
        MaxRetries int

        // RetryDelay for remote requests (default: 1s)
        RetryDelay time.Duration

        // HTTPTimeout for remote requests (default: 5s)
        HTTPTimeout time.Duration

        // InsecureSkipVerify allows skipping TLS certificate verification (default: false)
        // Only use in development environments
        InsecureSkipVerify bool

        // AllowEmptyFile if true, returns empty slice instead of error when file not found (default: false)
        AllowEmptyFile bool

        // AllowEmptyData if true, continues to next source even if current source returns empty data (default: false)
        AllowEmptyData bool

        // LoadStrategy determines how to combine data from multiple sources (default: LoadStrategyFallback)
        // - LoadStrategyFallback: return data from first successful source
        // - LoadStrategyMerge: merge data from all successful sources with deduplication
        LoadStrategy LoadStrategy

        // KeyFunc is required when LoadStrategy is LoadStrategyMerge
        // It extracts a unique key from each item for deduplication
        // Note: This is stored as interface{} and will be type-asserted in the loader
        KeyFunc interface{} // Should be KeyFunc[T] but we can't use generics in struct fields
}

// DefaultLoadOptions returns default load options
func DefaultLoadOptions() *LoadOptions <span class="cov10" title="40">{
        return &amp;LoadOptions{
                MaxFileSize:        10 * 1024 * 1024, // 10MB
                MaxRetries:         3,
                RetryDelay:         1 * time.Second,
                HTTPTimeout:        5 * time.Second,
                InsecureSkipVerify: false,
                AllowEmptyFile:     false,
                AllowEmptyData:     false,
                LoadStrategy:        LoadStrategyFallback,
                KeyFunc:             nil,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
